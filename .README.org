#+LATEX_HEADER: \newenvironment{lequation}{\begin{equation}\Large}{\end{equation}}
#+OPTIONS: ^:nil
#+ATTR_LATEX: :width 5cm :options angle=90
#+TITLE: Go-Functional
#+AUTHOR: yangruipis
#+EMAIL: yangruipis@163.com
#+KEYWORDS: 
#+OPTIONS: H:4 toc:t
#+OPTIONS: tex:t
#+SETUPFILE: https://gitee.com/yangruigit/my_blogs/raw/master/lib/theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+html: <div align="right">
#+html: </div>

** Features

Go-functional is inspired by [[https://github.com/EntilZha/PyFunctional][PyFunctional]] and [[https://github.com/thoas/go-funk][go-func]] . It makes golang struct data processing easier, especially when we have a data pipeline. Go-functionl is:

- FAST :: there is no reflect at all
- CHAIN :: chain functional operations
- LAZY :: most trainsformation operations are lazy evaluated
- SIMPLE :: use generic, all you need is a ~Map~ , instead of ~MapInt~ ~MapInt32~ ~MapInt64~ ...
- USER-FRIENDLY :: ~Spark~ style APIs is provided, maybe ~LinQ~ someday.

** Installation

~go>=1.18~

#+BEGIN_SRC
go get github.com/Yangruipis/go-functional
#+END_SRC

** Usage

#+BEGIN_SRC go
  package main

  import (
    "fmt"

    fun "github.com/Yangruipis/go-functional/pkg"
  )

  func main() {
    fun.RangeSeq(0, 10, 1).Map(func(k, v int) (int, int) {
      return k, v + 1
    }).Filter(func(k, v int) bool { return v >= 3 }).ForEach(func(i, v int) {
      fmt.Printf("%d\n", v)
    })
  }
#+END_SRC

** API list

There are two types of API(consistent with Spark):

1. Transformation: Iterator in, iterator out. Will not be executed until action operation. Iterator is supposed to be consumed only once.
2. Action: Iterator in, results out. All transformation operations are executed here (lazy exec).

| progress[34/49] | func        | signature                     | type                 |
|-----------------+-------------+-------------------------------+----------------------|
| [X]             | Map         | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Filter      | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Flatten     | [T1, []T2] -> [T1, T2]        | transformation       |
| [X]             | GroupBy     | [T1, T2] -> [T1, []T2]        | transformation       |
| [X]             | GroupByKey  | [T1, T2] -> [T1, []T2]        | transformation       |
| [X]             | GroupByVal  | [T1, T2] -> [T2, []T1]        | transformation       |
| [X]             | FlatMap     | [T1, []T2] -> [T1, []T2]      | transformation       |
| [X]             | ReduceByKey | [T1, []T2] -> [T1, T2]        | transformation       |
| [X]             | CountByKey  | [T1, T2] -> [T1, int]         | transformation       |
| [X]             | CountByVal  | [T1, T2] -> [T2, int]         | transformation       |
| [X]             | Union       | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | Intersect   | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | Subtract    | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | Distinct    | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | UnionBy     | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | IntersectBy | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | SubtractBy  | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | DistinctBy  | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Cartesian   | [T1, T2] [T1, T2] -> [T1, T2] | transformation       |
| [X]             | Chunk       | [T1, T2] -> [T1, []T2]        | transformation       |
| [X]             | Sort        | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Aggregate   | [T1, T2] -> [T1, O2]          | transformation       |
| [X]             | Zip         |                               | transformation       |
| [X]             | Invert      | [T1, T2] -> [T2, T1]          | transformation       |
| [X]             | Reverse     | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Shuffle     | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Sample      | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Choice      | [T1, T2] -> [T1, T2]          | transformation       |
| [ ]             | Head        | [T1, T2] -> [T1, T2]          | transformation       |
| [ ]             | Tail        | [T1, T2] -> [T1, T2]          | transformation       |
| [X]             | Repeat      | T -> [int, T]                 | transformation(init) |
| [X]             | Range       | int -> [int, int]             | transformation(init) |
| [X]             | Reduce      | [T1, T2] -> O                 | action               |
| [ ]             | Size        | [T1, T2] -> int               | action               |
| [ ]             | Exists      | [T1, T2] -> bool              | action               |
| [ ]             | All         | [T1, T2] -> bool              | action               |
| [ ]             | Any         | [T1, T2] -> bool              | action               |
| [ ]             | Count       | [T1, T2] -> int               | action               |
| [ ]             | ToSlice     | [T1, T2] -> []T2              | action               |
| [ ]             | ToMap       | [T1, T2] -> map[T1]T2         | action               |
| [ ]             | ToSet       | [T1, T2] -> map[T1]struct{}   | action               |
| [ ]             | Sum         | [T1, T2] -> int               | action               |
| [ ]             | Avg         | [T1, T2] -> int               | action               |
| [X]             | ForEach     | [T1, T2] ->                   | action               |
| [ ]             | Contains    | [T1, T2] -> bool              | action               |
| [ ]             | IndexOf     | [T1, T2] -> []int             | action               |
| [ ]             | LastIndexOf | [T1, T2] -> int               | action               |
| [X]             | Values      | [T1, T2] -> []T2              | action               |
| [X]             | Keys        | [T1, T2] -> []T1              | action               |


