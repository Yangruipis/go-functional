#+LATEX_HEADER: \newenvironment{lequation}{\begin{equation}\Large}{\end{equation}}
#+OPTIONS: ^:nil
#+ATTR_LATEX: :width 5cm :options angle=90
#+TITLE: Go-Functional
#+AUTHOR: yangruipis
#+EMAIL: yangruipis@163.com
#+KEYWORDS: 
#+OPTIONS: H:4 toc:t
#+OPTIONS: tex:t :exports both
#+SETUPFILE: https://gitee.com/yangruigit/my_blogs/raw/master/lib/theme-readtheorg.setup
#+HTML_HEAD: <style>pre.src{background:#343131;color:white;} </style>
#+html: <div align="right">
#+html: </div>

** Features

Go-functional is inspired by [[https://github.com/EntilZha/PyFunctional][PyFunctional]] and [[https://github.com/thoas/go-funk][go-func]] . It makes golang struct data processing easier, especially when we have a data pipeline. Go-functionl is:

- FAST :: there is no reflect at all
- CHAIN :: chain functional operations
- LAZY :: most trainsformation operations are lazy evaluated
- SIMPLE :: use generic, all you need is a ~Map~ , instead of ~MapInt~ ~MapInt32~ ~MapInt64~ ...
- USER-FRIENDLY :: ~Spark~ style APIs is provided, maybe ~LinQ~ someday.

** Installation ( go>=1.18 )

#+BEGIN_CENTER
go get github.com/Yangruipis/go-functional
#+END_CENTER

** Usage

*** basic import

#+begin_src go
  package main

  import (
    "fmt"

    "github.com/Yangruipis/go-functional/pkg/fn"
  )

  func main() {
    fn.RangeSeq(0, 10, 1).ForEach(func(i, v int) {
      fmt.Printf("%d\n", v)
    })
	}
#+end_src

*** Range -> Map -> Filter -> Print

#+begin_src go :imports '("fmt" "github.com/Yangruipis/go-functional/pkg/fn") :exports both :results output
      fn.RangeSeq(0, 10, 1).Map(
        func(k, v int) (int, int) {return k, v + 1 },
      ).Filter(
        func(k, v int) bool { return v >= 3 },
      ).ForEach(
        func(i, v int) { fmt.Printf("%d\n", v) },
      )
#+end_src

#+RESULTS:
: 3
: 4
: 5
: 6
: 7
: 8
: 9
: 10

*** Range -> Map -> GroupByKey -> Aggregate -> ForEach

#+begin_src go :imports '("fmt" "github.com/Yangruipis/go-functional/pkg/fn") :exports both :results output
  fn.RangeSeq(0, 10, 1).Map(
    func(k, v int) (int, int) {return k%2, v }, // split to 2 groups
  ).GroupByKey().Aggregate(func(vv []int) int {
    s := 0
    for _, v := range vv {
      s += v
    }
    return s
  }).ForEach(
    func(k int, v int) { fmt.Printf("sum of group %d is: %v\n", k, v) },
  )
#+end_src

#+RESULTS:
: mean of group 0 is: 20
: mean of group 1 is: 25

** API list

There are two types of API(consistent with Spark):

1. Transformation: Iterator in, iterator out. Will not be executed until action operation. Iterator is supposed to be consumed only once.
2. Action: Iterator in, results out. All transformation operations are executed here (lazy exec).

| func call[51/51] | chain call[33/51] | name        | signature                          | type                 |
|------------------+-------------------+-------------+------------------------------------+----------------------|
| ✅               | ✅                | Map         | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Filter      | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Flatten     | [T1, []T2] -> [T1, T2]             | transformation       |
| ✅               | ✅                | GroupBy     | [T1, T2] -> [T1, []T2]             | transformation       |
| ✅               | ✅                | GroupByKey  | [T1, T2] -> [T1, []T2]             | transformation       |
| ✅               | ❌                | GroupByVal  | [T1, T2] -> [T2, []T1]             | transformation       |
| ✅               | ✅                | FlatMap     | [T1, []T2] -> [T1, []T2]           | transformation       |
| ✅               | ✅                | ReduceByKey | [T1, []T2] -> [T1, T2]             | transformation       |
| ✅               | ✅                | CountByKey  | [T1, T2] -> [T1, int]              | transformation       |
| ✅               | ❌                | CountByVal  | [T1, T2] -> [T2, int]              | transformation       |
| ✅               | ❌                | Union       | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | Intersect   | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | Subtract    | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | Distinct    | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ❌                | UnionBy     | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | IntersectBy | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | SubtractBy  | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ❌                | DistinctBy  | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ❌                | Cartesian   | [T1, T2] [T1, T2] -> [T1, T2]      | transformation       |
| ✅               | ✅                | Chunk       | [T1, T2] -> [T1, []T2]             | transformation       |
| ✅               | ✅                | Sort        | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Aggregate   | [T1, T2] -> [T1, O2]               | transformation       |
| ✅               | ❌                | Zip         | [T1, T2] [T1, O2]-> [T1, [T2, O2]] | transformation       |
| ✅               | ❌                | Invert      | [T1, T2] -> [T2, T1]               | transformation       |
| ✅               | ✅                | Reverse     | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Shuffle     | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Sample      | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Choices     | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Head        | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Tail        | [T1, T2] -> [T1, T2]               | transformation       |
| ✅               | ✅                | Repeat      | T -> [int, T]                      | transformation(init) |
| ✅               | ✅                | Range       | int -> [int, int]                  | transformation(init) |
| ✅               | ✅                | Reduce      | [T1, T2] -> O                      | action               |
| ✅               | ✅                | Size        | [T1, T2] -> int                    | action               |
| ✅               | ✅                | Exists      | [T1, T2] -> bool                   | action               |
| ✅               | ✅                | ExistsBy    | [T1, T2] -> bool                   | action               |
| ✅               | ✅                | All         | [T1, T2] -> bool                   | action               |
| ✅               | ✅                | Any         | [T1, T2] -> bool                   | action               |
| ✅               | ✅                | Count       | [T1, T2] -> int                    | action               |
| ✅               | ✅                | CountBy     | [T1, T2] -> int                    | action               |
| ✅               | ✅                | ToSlice     | [T1, T2] -> []T2                   | action               |
| ✅               | ✅                | ToMap       | [T1, T2] -> map[T1]T2              | action               |
| ✅               | ❌                | ToSet       | [T1, T2] -> map[T1]struct{}        | action               |
| ✅               | ❌                | Sum         | [T1, T2] -> int                    | action               |
| ✅               | ❌                | Avg         | [T1, T2] -> int                    | action               |
| ✅               | ✅                | ForEach     | [T1, T2] ->                        | action               |
| ✅               | ✅                | Entries     | [T1, T2] -> [][T1, T2]             | action               |
| ✅               | ❌                | IndexOf     | [T1, T2] -> []int                  | action               |
| ✅               | ❌                | NIndexOf    | [T1, T2] -> int                    | action               |
| ✅               | ✅                | Values      | [T1, T2] -> []T2                   | action               |
| ✅               | ✅                | Keys        | [T1, T2] -> []T1                   | action               |


