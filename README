                            â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
                             GO-FUNCTIONAL

                               yangruipis
                            â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”


Table of Contents
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

1. Features
2. Installation ( go>=1.18 )
3. Usage
.. 1. basic import
.. 2. Range -> Map -> Filter -> ForEach
.. 3. Range -> Map -> GroupByKey -> Aggregate -> ForEach
.. 4. multi path with cache: Range -> Map -> Cache ( â€“> Filter ) & ( â€“> Shuffle )
4. API list





1 Features
â•â•â•â•â•â•â•â•â•â•

  Go-functional is inspired by [PyFunctional] and [go-func] . It makes
  golang struct data processing easier, especially when we have a data
  pipeline. Go-functionl is:

  âš¡ï¸ FAST
        there is no reflect at all
  â›“ï¸  CHAIN
        chain functional operations
  ğŸ¬ LAZY
        most trainsformation operations are lazy evaluated
  âœ¨ SIMPLE
        use generic, all you need is a `Map' , instead of `MapInt'
        `MapInt32' `MapInt64' â€¦
  ğŸ‘¥ USER-FRIENDLY
        `Spark' style APIs is provided, maybe `LinQ' someday.


[PyFunctional] <https://github.com/EntilZha/PyFunctional>

[go-func] <https://github.com/thoas/go-funk>


2 Installation ( go>=1.18 )
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

                go get github.com/Yangruipis/go-functional


3 Usage
â•â•â•â•â•â•â•

3.1 basic import
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ package main
  â”‚ 
  â”‚ import (
  â”‚   "fmt"
  â”‚ 
  â”‚   "github.com/Yangruipis/go-functional/pkg/fn"
  â”‚ )
  â”‚ 
  â”‚ func main() {
  â”‚   fn.RangeSeq(0, 10, 1).ForEach(func(i, v int) {
  â”‚     fmt.Printf("%d\n", v)
  â”‚   })
  â”‚ }
  â””â”€â”€â”€â”€


3.2 Range -> Map -> Filter -> ForEach
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ fn.RangeSeq(0, 10, 1).Map(
  â”‚   func(k, v int) (int, int) {return k, v + 1 },
  â”‚ ).Filter(
  â”‚   func(k, v int) bool { return v >= 3 },
  â”‚ ).ForEach(
  â”‚   func(i, v int) { fmt.Printf("%d\n", v) },
  â”‚ )
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ 3
  â”‚ 4
  â”‚ 5
  â”‚ 6
  â”‚ 7
  â”‚ 8
  â”‚ 9
  â”‚ 10
  â””â”€â”€â”€â”€


3.3 Range -> Map -> GroupByKey -> Aggregate -> ForEach
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ fn.RangeSeq(0, 10, 1).Map(
  â”‚   func(k, v int) (int, int) {return k%2, v }, // split to 2 groups
  â”‚ ).GroupByKey().Aggregate(func(vv []int) int {
  â”‚   s := 0
  â”‚   for _, v := range vv {
  â”‚     s += v
  â”‚   }
  â”‚   return s
  â”‚ }).ForEach(
  â”‚   func(k int, v int) { fmt.Printf("sum of group %d is: %v\n", k, v) },
  â”‚ )
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ sum of group 0 is: 20
  â”‚ sum of group 1 is: 25
  â””â”€â”€â”€â”€


3.4 multi path with cache: Range -> Map -> Cache ( â€“> Filter ) & ( â€“> Shuffle )
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ c := fn.RangeSeq(0, 10, 1).Map(
  â”‚   func(k, v int) (int, int) { return k, v * 2 },
  â”‚ ).Cache()
  â”‚ 
  â”‚ c1 := c.Filter(func(k, v int) bool { return v >= 10 } )
  â”‚ fmt.Printf("paths: %v, results: %v \n", c1.Paths, c1.ToSlice())
  â”‚ 
  â”‚ c2 := c.Shuffle()
  â”‚ fmt.Printf("paths: %v, results: %v \n", c2.Paths, c2.ToSlice())
  â””â”€â”€â”€â”€

  â”Œâ”€â”€â”€â”€
  â”‚ paths: [Map Cache Filter], results: [10 12 14 16 18] 
  â”‚ paths: [Map Cache Shuffle], results: [2 14 8 0 18 4 6 10 16 12]
  â””â”€â”€â”€â”€


4 API list
â•â•â•â•â•â•â•â•â•â•

  There are two types of API(consistent with Spark):

  1. Transformation: Iterator in, iterator out. Will not be executed
     until action operation. Iterator is supposed to be consumed only
     once.
  2. Action: Iterator in, results out. All transformation operations are
     executed here (lazy exec).

  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
   func call[51/51]  chain call[33/51]  name         signature                      type                 
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âœ…                âœ…                 Map          [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Filter       [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Flatten      [K, []V] -> [K, V]             transformation       
   âœ…                âœ…                 GroupBy      [K, V] -> [K, []V]             transformation       
   âœ…                âœ…                 GroupByKey   [K, V] -> [K, []V]             transformation       
   âœ…                âŒ                 GroupByVal   [K, V] -> [V, []K]             transformation       
   âœ…                âœ…                 FlatMap      [K, []V] -> [K, []V]           transformation       
   âœ…                âœ…                 ReduceByKey  [K, []V] -> [K, V]             transformation       
   âœ…                âœ…                 CountByKey   [K, V] -> [K, int]             transformation       
   âœ…                âŒ                 CountByVal   [K, V] -> [V, int]             transformation       
   âœ…                âŒ                 Union        [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 Intersect    [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 Subtract     [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 Distinct     [K, V] -> [K, V]               transformation       
   âœ…                âŒ                 UnionBy      [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 IntersectBy  [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 SubtractBy   [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âŒ                 DistinctBy   [K, V] -> [K, V]               transformation       
   âœ…                âŒ                 Cartesian    [K, V] [K, V] -> [K, V]        transformation       
   âœ…                âœ…                 Chunk        [K, V] -> [K, []V]             transformation       
   âœ…                âœ…                 Sort         [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Aggregate    [K, V] -> [K, V1]              transformation       
   âœ…                âŒ                 Zip          [K, V] [K, V1]-> [K, [V, V1]]  transformation       
   âœ…                âŒ                 Invert       [K, V] -> [V, K]               transformation       
   âœ…                âœ…                 Reverse      [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Shuffle      [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Sample       [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Choices      [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Head         [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Tail         [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Cache        [K, V] -> [K, V]               transformation       
   âœ…                âœ…                 Repeat       V -> [int, V]                  transformation(init) 
   âœ…                âœ…                 Range        int -> [int, int]              transformation(init) 
   âœ…                âœ…                 Reduce       [K, V] -> V                    action               
   âœ…                âœ…                 Size         [K, V] -> int                  action               
   âœ…                âœ…                 Exists       [K, V] -> bool                 action               
   âœ…                âœ…                 ExistsBy     [K, V] -> bool                 action               
   âœ…                âœ…                 All          [K, V] -> bool                 action               
   âœ…                âœ…                 Any          [K, V] -> bool                 action               
   âœ…                âœ…                 Count        [K, V] -> int                  action               
   âœ…                âœ…                 CountBy      [K, V] -> int                  action               
   âœ…                âœ…                 ToSlice      [K, V] -> []V                  action               
   âœ…                âœ…                 ToMap        [K, V] -> map[K]V              action               
   âœ…                âŒ                 ToSet        [K, V] -> map[K]struct{}       action               
   âœ…                âŒ                 Sum          [K, V] -> int                  action               
   âœ…                âŒ                 Avg          [K, V] -> int                  action               
   âœ…                âœ…                 ForEach      [K, V] -> void                 action               
   âœ…                âœ…                 Entries      [K, V] -> [][K, V]             action               
   âœ…                âŒ                 IndexOf      [K, V] -> []int                action               
   âœ…                âŒ                 NIndexOf     [K, V] -> int                  action               
   âœ…                âœ…                 Values       [K, V] -> []V                  action               
   âœ…                âœ…                 Keys         [K, V] -> []K                  action               
  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
